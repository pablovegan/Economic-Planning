{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Economic Planning","text":"<p>A simple example package for economic planning.</p>"},{"location":"#documentation-and-examples","title":"Documentation and examples","text":"<p>Documentation and examples can be found in https://pablovegan.github.io/Economic-Planning/.</p>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>: <pre><code>pip install git+https://github.com/pablovegan/Economic-Planning.git\n</code></pre></p>"},{"location":"#quick-usage","title":"Quick usage","text":"<p>See the notebooks of planning of the Spanish and Swedish economies.</p>"},{"location":"#to-do","title":"To do","text":"<ul> <li>[ ] Add other nonlinear cost functions (e.g. harmony function)</li> </ul>"},{"location":"#understanding-the-algorithm","title":"Understanding the algorithm","text":""},{"location":"#autarky","title":"Autarky","text":"<p>Let's begin with a simple example: a self-sufficient economy without external commerce. In order to feed our population, we need to produce more than we consume:  But something is wrong. In order to produce, we also need to consume goods, so we need to substract the used goods in the production:  This is going to be our main constraint. From now on, we are simply going to add more complexity to the model in order to make it more realistic.</p> <p>Since we are producing more than we need, there will possibly be some excess production that we can reuse in the next period. But not all excess will be available: food spoils, machines wear out, etc. To model this, we add a depreciation  </p>"},{"location":"#introducing-trade","title":"Introducing trade","text":"<p>What happens if we need to import part of the goods from external economies, both for final consumption and for intermediate production?   (To avoid clogging the equation, we will temporarily remove the $excess$ term of the inequality).</p> <p>Supposing we use in each period what we import, we can equal  and remove the terms from the inequality (this restriction can be relaxed). </p> <p>This may seem like imports are not considered in our algorithm... but they are. We cannot import all the goods we want, if that happened we wouldn't need to work! To import goods from other economies we need to export something in exchange.  This allows us to introduce yet another kind of restriction: a balance of trade. To do this we need some kind of unifying measure to compare 'how much' we import and export. Usually, this is done with one-dimensional quantity, prices, but we could use other measures like labour time, energy or even multidimensional units. For now, lets keep it simple and assume we want to export more than we import:  </p>"},{"location":"#references","title":"References","text":"<p>This package is inspired by Hagberg's and Zacharia's receding horizon planning repository and Hagberg's thesis.</p> <p>Great Python packages exist for input-output analysis, such as Pymrio, altough it is not focused on planning.</p> <p>Pymrio \u2013 A Python Based Multi-Regional Input-Output Analysis Toolbox. Konstantin Stadler (2021). https://openresearchsoftware.metajnl.com/articles/10.5334/jors.251</p> <p>Life cycle assessment package https://github.com/brightway-lca/brightway2</p> <p>ODYM - Open Dynamic Material Systems Model https://github.com/IndEcol/ODYM</p> <p>Lifting Industrial Ecology Modeling to a New Level of Quality and Transparency: A Call for More Transparent Publications and a Collaborative Open Source Software Framework https://onlinelibrary.wiley.com/doi/full/10.1111/jiec.12316</p> <p>J. M. Montias. Planning with Material Balances in Soviet-Type Economies</p> <p>Spanish supply-use tables can be found in the website of the National Statistics Institute (INE).</p> <p>Introduction to control theory. https://fab.cba.mit.edu/classes/865.21/topics/control/</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We appreciate and welcome contributions. For major changes, please open an issue first to discuss what you would like to change. Also, make sure to update tests as appropriate.</p> <p>If you are new to contributing to open source, this guide helps explain why, what, and how to get involved.</p>"},{"location":"#license","title":"License","text":"<p>This software is under the GNU General Public License v3.0.</p>"},{"location":"examples/spain/","title":"Spanish economy","text":"<p>Let's begin importing the data in a dictionary for the periods we want to plan. The data has been saved from the excel files using the <code>save_data.py</code> script.</p> In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom pickle import load\n\nimport numpy as np\n\nfrom planning import Economy, Ecology, TargetEconomy, TargetEcology\n\n\nwith Path('data', 'economy.pkl').open('rb') as f:\n    economy_dict = load(f)\n    economy = Economy(**economy_dict)\n\nwith Path('data', 'target_economy.pkl').open('rb') as f:\n    target_economy_dict = load(f)\n    target_economy = TargetEconomy(**target_economy_dict)\n\nwith Path('data', 'ecology.pkl').open('rb') as f:\n    ecology_dict = load(f)\n    ecology = Ecology(**ecology_dict)\n\nwith Path('data', 'target_ecology.pkl').open('rb') as f:\n    target_ecology_dict = load(f)\n    target_ecology = TargetEcology(**target_ecology_dict)\n</pre> from pathlib import Path from pickle import load  import numpy as np  from planning import Economy, Ecology, TargetEconomy, TargetEcology   with Path('data', 'economy.pkl').open('rb') as f:     economy_dict = load(f)     economy = Economy(**economy_dict)  with Path('data', 'target_economy.pkl').open('rb') as f:     target_economy_dict = load(f)     target_economy = TargetEconomy(**target_economy_dict)  with Path('data', 'ecology.pkl').open('rb') as f:     ecology_dict = load(f)     ecology = Ecology(**ecology_dict)  with Path('data', 'target_ecology.pkl').open('rb') as f:     target_ecology_dict = load(f)     target_ecology = TargetEcology(**target_ecology_dict) <p>The data is aggregated into 110 products and 81 sectors:</p> In\u00a0[2]: Copied! <pre>economy.product_names[:5]\n</pre> economy.product_names[:5] Out[2]: <pre>['1. Products of agriculture',\n '2. Live animals and animal products',\n '3. Agricultural and animal husbandry services',\n '4. Products of forestry, logging and related services',\n '5 .Fish and other fishing products; aquaculture products; support services to fishing']</pre> In\u00a0[3]: Copied! <pre>economy.sector_names[:5]\n</pre> economy.sector_names[:5] Out[3]: <pre>['Crop and animal production, hunting and related service activities\\n  ',\n 'Forestry and logging',\n 'Fishing and aquaculture',\n 'Mining and quarrying',\n 'Processing and preserving of meat and production of meat products']</pre> In\u00a0[4]: Copied! <pre>ecology.pollutant_names\n</pre> ecology.pollutant_names Out[4]: <pre>['1.- GEI - Gases de efecto invernadero (miles de toneladas de CO2 equivalente)',\n '1.1- CO2 - Di\u00f3xido de carbono (miles de toneladas de CO2 equivalente)',\n '1.2- CH4 - Metano (miles de toneladas de CO2 equivalente)',\n '1.3- N2O - \u00d3xido nitroso (miles de toneladas de CO2 equivalente)',\n '1.4- PFC - Perfluorocarbonos o compuestos polifluorcarbonados (miles de toneladas de CO2 equivalente)',\n '1.5- HFC - Hidrofluorocarbonos o compuestos hidrogenofluorcarbonados (miles de toneladas de CO2 equivalente)',\n '1.6- SF6  - Hexafluoruro de azufre (miles de toneladas de CO2 equivalente)',\n '2.- GAC- Gases acidificantes (toneladas de SO2 equivalentes)',\n '2.1- SOx  - \u00d3xidos de azufre (toneladas de SO2 equivalentes)',\n '2.2- NOx  - \u00d3xidos de nitr\u00f3geno (toneladas de SO2 equivalentes)',\n '2.3- NH3  - Amoniaco (toneladas de SO2 equivalentes)',\n '3.- PRO3- Gases precursores de ozono troposf\u00e9rico (toneladas de COVNM equivalentes)',\n '3.1- COVNM - Compuestos org\u00e1nicos vol\u00e1tiles no met\u00e1nicos (toneladas)']</pre> <p>We will plan the economy for 6 periods with a horizon of 2 periods and revising the plan after 1 period (apply one periods and discard the other).</p> In\u00a0[5]: Copied! <pre>from planning import OptimizePlan\n\nperiods = 6\nhorizon_periods = 2\nrevise_periods = 1\n\nplan = OptimizePlan(\n    periods = periods,\n    horizon_periods = horizon_periods, \n    revise_periods = revise_periods,\n    economy = economy,\n    ecology = ecology\n)\n\nplanned_economy, planned_ecology = plan(\n    target_economy,\n    target_ecology,\n    init_surplus=target_economy.domestic[0] / 12,  # np.zeros(economy.products)\n    init_export_deficit=0  \n)\n</pre> from planning import OptimizePlan  periods = 6 horizon_periods = 2 revise_periods = 1  plan = OptimizePlan(     periods = periods,     horizon_periods = horizon_periods,      revise_periods = revise_periods,     economy = economy,     ecology = ecology )  planned_economy, planned_ecology = plan(     target_economy,     target_ecology,     init_surplus=target_economy.domestic[0] / 12,  # np.zeros(economy.products)     init_export_deficit=0   ) <pre>/Users/KaerMorhen/miniconda3/envs/plan/lib/python3.11/site-packages/cvxpy/problems/problem.py:1385: UserWarning: Solution may be inaccurate. Try another solver, adjusting the solver settings, or solve with verbose=True for more information.\n  warnings.warn(\n</pre> In\u00a0[6]: Copied! <pre>activity = np.array(planned_economy.activity).T\nproduction = np.array(planned_economy.production).T\nsurplus = np.array(planned_economy.surplus).T\ntotal_import = np.array(planned_economy.total_import).T\nexport_deficit = np.array(planned_economy.export_deficit)\nworked_hours = np.array(planned_economy.worked_hours)\npollutants = np.array(planned_ecology.pollutants).T\n</pre> activity = np.array(planned_economy.activity).T production = np.array(planned_economy.production).T surplus = np.array(planned_economy.surplus).T total_import = np.array(planned_economy.total_import).T export_deficit = np.array(planned_economy.export_deficit) worked_hours = np.array(planned_economy.worked_hours) pollutants = np.array(planned_ecology.pollutants).T In\u00a0[7]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.style.use('seaborn-v0_8-whitegrid')\n\ncolors = plt.cm.nipy_spectral(np.linspace(0, 1, economy.products))\n</pre> import matplotlib.pyplot as plt  plt.style.use('seaborn-v0_8-whitegrid')  colors = plt.cm.nipy_spectral(np.linspace(0, 1, economy.products)) <p>We planned for 3 years and the interpolation between them (mYEAR).</p> In\u00a0[8]: Copied! <pre>periods = ['2016', 'm2016', '2017', 'm2017', '2018', 'm2018', '2019']\n</pre> periods = ['2016', 'm2016', '2017', 'm2017', '2018', 'm2018', '2019'] In\u00a0[9]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Evolution of the activity in each period.', size = 16)\n\nfor i in range(economy.sectors):\n    ax.plot(periods[: plan.periods], activity[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Activity of the unit', size = 14)\nax.set_yscale('log')\n\nplt.savefig(Path('figures', 'unit_activity.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Evolution of the activity in each period.', size = 16)  for i in range(economy.sectors):     ax.plot(periods[: plan.periods], activity[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Activity of the unit', size = 14) ax.set_yscale('log')  plt.savefig(Path('figures', 'unit_activity.png')) <p>The planned activity of each sector provides the planned production</p> In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Evolution of planned production in each period.', size = 16)\n\nfor i in range(economy.products):\n    ax.plot(periods[: plan.periods], production[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Production', size = 14)\n\nplt.savefig(Path('figures', 'planned_prod.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Evolution of planned production in each period.', size = 16)  for i in range(economy.products):     ax.plot(periods[: plan.periods], production[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Production', size = 14)  plt.savefig(Path('figures', 'planned_prod.png')) <p>Note that some periods have negative production. This means that either we are consuming excess goods from previous periods or, most likely, we are importing those producs.</p> In\u00a0[11]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Evolution of planned production in each period.', size = 16)\n\nax.plot(periods[: plan.periods], production[25, :], label=economy.product_names[25])\nax.plot(periods[: plan.periods], production[26, :], label='27. Basic chemicals')\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Production', size = 14)\nax.legend(loc=\"lower left\")\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Evolution of planned production in each period.', size = 16)  ax.plot(periods[: plan.periods], production[25, :], label=economy.product_names[25]) ax.plot(periods[: plan.periods], production[26, :], label='27. Basic chemicals')  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Production', size = 14) ax.legend(loc=\"lower left\") Out[11]: <pre>&lt;matplotlib.legend.Legend at 0x1634783d0&gt;</pre> In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Evolution of excess production in each period.', size = 16)\n\nfor i in range(economy.products):\n    ax.plot(periods[: plan.periods], surplus[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Excess production', size = 14)\n\nplt.savefig(Path('figures', 'excess_prod.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Evolution of excess production in each period.', size = 16)  for i in range(economy.products):     ax.plot(periods[: plan.periods], surplus[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Excess production', size = 14)  plt.savefig(Path('figures', 'excess_prod.png')) <p>Note how the excess of some products keeps rising</p> In\u00a0[13]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Evolution of excess production in each period.', size = 16)\n\nax.plot(periods[: plan.periods], surplus[63, :], label=economy.product_names[63])\nax.plot(periods[: plan.periods], surplus[64, :], label=economy.product_names[64])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Excess production', size = 14)\nax.legend()\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Evolution of excess production in each period.', size = 16)  ax.plot(periods[: plan.periods], surplus[63, :], label=economy.product_names[63]) ax.plot(periods[: plan.periods], surplus[64, :], label=economy.product_names[64])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Excess production', size = 14) ax.legend() Out[13]: <pre>&lt;matplotlib.legend.Legend at 0x1636b3c10&gt;</pre> <p>While others, like excess food, remains almost zero.</p> In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle(r'Excess agriculture products in each period.', size = 16)\n\nax.plot(periods[: plan.periods], surplus[0, :], c=colors[0, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel(\"Excess Agrigulture products\", size = 14)\n\nplt.savefig(Path('figures', 'excess_agriculture.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle(r'Excess agriculture products in each period.', size = 16)  ax.plot(periods[: plan.periods], surplus[0, :], c=colors[0, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel(\"Excess Agrigulture products\", size = 14)  plt.savefig(Path('figures', 'excess_agriculture.png')) In\u00a0[15]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Evolution of imported final goods in each period.', size = 16)\n\nfor i in range(economy.products):\n    ax.plot(periods[: plan.periods], total_import[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Imported final', size = 14)\n\nplt.savefig(Path('figures', 'planned_prod.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Evolution of imported final goods in each period.', size = 16)  for i in range(economy.products):     ax.plot(periods[: plan.periods], total_import[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Imported final', size = 14)  plt.savefig(Path('figures', 'planned_prod.png')) In\u00a0[16]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Evolution of imported final goods in each period.', size = 16)\n\nax.plot(periods[: plan.periods], total_import[25, :], label=economy.product_names[25])\nax.plot(periods[: plan.periods], total_import[26, :], label='27. Basic chemicals')\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Imported final', size = 14)\nax.legend(loc=\"upper left\")\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Evolution of imported final goods in each period.', size = 16)  ax.plot(periods[: plan.periods], total_import[25, :], label=economy.product_names[25]) ax.plot(periods[: plan.periods], total_import[26, :], label='27. Basic chemicals')  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Imported final', size = 14) ax.legend(loc=\"upper left\") Out[16]: <pre>&lt;matplotlib.legend.Legend at 0x13fdb3f10&gt;</pre> In\u00a0[17]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Export deficit in each period.', size = 16)\n\nax.plot(periods[: plan.periods], export_deficit)\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Deficit in $', size = 14)\n\nplt.savefig(Path('figures', 'export_deficit.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Export deficit in each period.', size = 16)  ax.plot(periods[: plan.periods], export_deficit)  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Deficit in $', size = 14)  plt.savefig(Path('figures', 'export_deficit.png')) In\u00a0[18]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Total worked hours in each period.', size = 16)\n\nax.plot(periods[: plan.periods], worked_hours)\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Time in hours', size = 14)\n\nplt.savefig(Path('figures', 'worked_hours.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Total worked hours in each period.', size = 16)  ax.plot(periods[: plan.periods], worked_hours)  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Time in hours', size = 14)  plt.savefig(Path('figures', 'worked_hours.png')) In\u00a0[19]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize = (8, 6))\nfig.suptitle('Produced pollutants in each period.', size = 16)\n\nfor i in range(len(ecology.pollutant_names)):\n    ax.plot(periods[: plan.periods], pollutants[i, :], label=ecology.pollutant_names[i])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel('Period', size = 14)\nax.set_ylabel('Pollutant', size = 14)\nax.legend(bbox_to_anchor=(1, 1))\n\nplt.savefig(Path('figures', 'pollutants.png'))\n</pre> fig, ax = plt.subplots(1,1, figsize = (8, 6)) fig.suptitle('Produced pollutants in each period.', size = 16)  for i in range(len(ecology.pollutant_names)):     ax.plot(periods[: plan.periods], pollutants[i, :], label=ecology.pollutant_names[i])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel('Period', size = 14) ax.set_ylabel('Pollutant', size = 14) ax.legend(bbox_to_anchor=(1, 1))  plt.savefig(Path('figures', 'pollutants.png'))"},{"location":"examples/spain/#planning-the-spanish-economy","title":"Planning the spanish economy\u00b6","text":""},{"location":"examples/spain/#the-plan","title":"The plan\u00b6","text":""},{"location":"examples/spain/#visualizing-the-results","title":"Visualizing the results\u00b6","text":""},{"location":"examples/spain/#production-unit-activity","title":"Production unit activity\u00b6","text":""},{"location":"examples/spain/#production","title":"Production\u00b6","text":""},{"location":"examples/spain/#excess-production","title":"Excess production\u00b6","text":""},{"location":"examples/spain/#imported-goods","title":"Imported goods\u00b6","text":""},{"location":"examples/spain/#export-deficit","title":"Export deficit\u00b6","text":""},{"location":"examples/spain/#total-worked-hours","title":"Total worked hours\u00b6","text":""},{"location":"examples/spain/#pollutants","title":"Pollutants\u00b6","text":""},{"location":"examples/sweden/","title":"Swedish economy","text":"<p>Let's begin importing the data in a dictionary for the periods we want to plan. The data has been saved from the excel files using the <code>save_data.py</code> script.</p> In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom pickle import load\n\nimport numpy as np\n\nfrom planning import Economy, TargetEconomy\n\n\nwith Path('data', 'economy.pkl').open('rb') as f:\n    economy_dict = load(f)\n    economy = Economy(**economy_dict)\n\nwith Path('data', 'target_economy.pkl').open('rb') as f:\n    target_economy_dict = load(f)\n    target_economy = TargetEconomy(**target_economy_dict)\n</pre> from pathlib import Path from pickle import load  import numpy as np  from planning import Economy, TargetEconomy   with Path('data', 'economy.pkl').open('rb') as f:     economy_dict = load(f)     economy = Economy(**economy_dict)  with Path('data', 'target_economy.pkl').open('rb') as f:     target_economy_dict = load(f)     target_economy = TargetEconomy(**target_economy_dict) <p>The products and production units are the same since the data is aggregated (except there is a CO2 product but not a CO2 sector):</p> In\u00a0[2]: Copied! <pre>economy.product_names[:5]\n</pre> economy.product_names[:5] Out[2]: <pre>['Products of agriculture, hunting and related services',\n 'Products of forestry, logging and related services',\n 'Fish and other fishing products; aquaculture products; support services to fishing',\n 'Mining and quarrying',\n 'Food products, beverages and tobacco products']</pre> <p>We will plan the economy for 15 periods with a horizon of 5 periods and revising the plan after 3 periods (apply these 3 periods and discard the other 2).</p> In\u00a0[3]: Copied! <pre>len(economy.supply)\n</pre> len(economy.supply) Out[3]: <pre>17</pre> In\u00a0[4]: Copied! <pre>from planning import OptimizePlan\n\nperiods = 15\nhorizon_periods = 5\nrevise_periods = 3\n\nplan = OptimizePlan(\n    periods = periods,\n    horizon_periods = horizon_periods, \n    revise_periods = revise_periods,\n    economy = economy,\n    ecology = None\n)\n\nplanned = plan(\n    target_economy,\n    target_ecology=None,\n    init_surplus=target_economy.domestic[0] / 12,  # np.zeros(economy.products)\n    init_export_deficit=0  \n)\n</pre> from planning import OptimizePlan  periods = 15 horizon_periods = 5 revise_periods = 3  plan = OptimizePlan(     periods = periods,     horizon_periods = horizon_periods,      revise_periods = revise_periods,     economy = economy,     ecology = None )  planned = plan(     target_economy,     target_ecology=None,     init_surplus=target_economy.domestic[0] / 12,  # np.zeros(economy.products)     init_export_deficit=0   ) In\u00a0[5]: Copied! <pre>activity = np.array(planned.activity).T\nproduction = np.array(planned.production).T\nsurplus = np.array(planned.surplus).T\ntotal_import = np.array(planned.total_import).T\nexport_deficit = np.array(planned.export_deficit)\nworked_hours = np.array(planned.worked_hours)\n</pre> activity = np.array(planned.activity).T production = np.array(planned.production).T surplus = np.array(planned.surplus).T total_import = np.array(planned.total_import).T export_deficit = np.array(planned.export_deficit) worked_hours = np.array(planned.worked_hours) In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\nfrom numpy import linspace\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\n\ncolors = plt.cm.nipy_spectral(linspace(0, 1, economy.products))\n</pre> import matplotlib.pyplot as plt from numpy import linspace  plt.style.use(\"seaborn-v0_8-whitegrid\")  colors = plt.cm.nipy_spectral(linspace(0, 1, economy.products)) <p>We planned for 9 years and the interpolation between them (mYEAR).</p> In\u00a0[7]: Copied! <pre>periods = [\n    \"2008\",\n    \"m2008\",\n    \"2009\",\n    \"m2009\",\n    \"2010\",\n    \"m2010\",\n    \"2011\",\n    \"m2011\",\n    \"2012\",\n    \"m2012\",\n    \"2013\",\n    \"m2013\",\n    \"2014\",\n    \"m2014\",\n    \"2015\",\n    \"m2015\",\n    \"2016\",\n    \"m2016\",\n]\n</pre> periods = [     \"2008\",     \"m2008\",     \"2009\",     \"m2009\",     \"2010\",     \"m2010\",     \"2011\",     \"m2011\",     \"2012\",     \"m2012\",     \"2013\",     \"m2013\",     \"2014\",     \"m2014\",     \"2015\",     \"m2015\",     \"2016\",     \"m2016\", ] In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(\"Evolution of the activity in each period.\", size=16)\n\nfor i in range(economy.sectors):\n    ax.plot(periods[: plan.periods], activity[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(\"Activity of the unit\", size=14)\n\nplt.savefig(Path(\"figures\", \"unit_activity.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(\"Evolution of the activity in each period.\", size=16)  for i in range(economy.sectors):     ax.plot(periods[: plan.periods], activity[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(\"Activity of the unit\", size=14)  plt.savefig(Path(\"figures\", \"unit_activity.png\")) <p>Note that a period with negative production means that more product was used than supplied.</p> In\u00a0[9]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(\"Evolution of planned production in each period.\", size=16)\n\nfor i in range(economy.products):\n    ax.plot(periods[: plan.periods], production[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(\"Production\", size=14)\n\nplt.savefig(Path(\"figures\", \"planned_prod.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(\"Evolution of planned production in each period.\", size=16)  for i in range(economy.products):     ax.plot(periods[: plan.periods], production[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(\"Production\", size=14)  plt.savefig(Path(\"figures\", \"planned_prod.png\")) In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(\"Evolution of excess production in each period.\", size=16)\n\nfor i in range(economy.products):\n    ax.plot(periods[: plan.periods], surplus[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(\"Excess production\", size=14)\n\nplt.savefig(Path(\"figures\", \"excess_prod.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(\"Evolution of excess production in each period.\", size=16)  for i in range(economy.products):     ax.plot(periods[: plan.periods], surplus[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(\"Excess production\", size=14)  plt.savefig(Path(\"figures\", \"excess_prod.png\")) <p>Note how carbon dioxide keeps rising since it is not used.</p> In\u00a0[11]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(r\"Excess $CO_2$ in each period.\", size=16)\n\nax.plot(periods[: plan.periods], surplus[59, :], c=colors[59, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(economy.product_names[59], size=14)\n\nplt.savefig(Path(\"figures\", \"excess_co2.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(r\"Excess $CO_2$ in each period.\", size=16)  ax.plot(periods[: plan.periods], surplus[59, :], c=colors[59, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(economy.product_names[59], size=14)  plt.savefig(Path(\"figures\", \"excess_co2.png\")) In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(\"Excess food in each period.\", size=16)\n\nax.plot(periods[: plan.periods], surplus[4, :], c=colors[4, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(economy.product_names[4], size=14)\n\nplt.savefig(Path(\"figures\", \"excess_food.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(\"Excess food in each period.\", size=16)  ax.plot(periods[: plan.periods], surplus[4, :], c=colors[4, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(economy.product_names[4], size=14)  plt.savefig(Path(\"figures\", \"excess_food.png\")) In\u00a0[13]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(\"Evolution of imported final goods in each period.\", size=16)\n\nfor i in range(economy.products):\n    ax.plot(periods[: plan.periods], total_import[i, :], c=colors[i, :])\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(\"Imported final\", size=14)\n\nplt.savefig(Path(\"figures\", \"planned_prod.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(\"Evolution of imported final goods in each period.\", size=16)  for i in range(economy.products):     ax.plot(periods[: plan.periods], total_import[i, :], c=colors[i, :])  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(\"Imported final\", size=14)  plt.savefig(Path(\"figures\", \"planned_prod.png\")) In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(\"Export deficit in each period.\", size=16)\n\nax.plot(periods[: plan.periods], export_deficit)\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(\"Deficit in $\", size=14)\n\nplt.savefig(Path(\"figures\", \"export_deficit.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(\"Export deficit in each period.\", size=16)  ax.plot(periods[: plan.periods], export_deficit)  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(\"Deficit in $\", size=14)  plt.savefig(Path(\"figures\", \"export_deficit.png\")) In\u00a0[15]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfig.suptitle(\"Total worked hours in each period.\", size=16)\n\nax.plot(periods[: plan.periods], worked_hours)\n\nplan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1])\nax.set_xlabel(\"Period\", size=14)\nax.set_ylabel(\"Time in hours\", size=14)\n\nplt.savefig(Path(\"figures\", \"worked_hours.png\"))\n</pre> fig, ax = plt.subplots(1, 1, figsize=(8, 6)) fig.suptitle(\"Total worked hours in each period.\", size=16)  ax.plot(periods[: plan.periods], worked_hours)  plan_lims = ax.set_xlim(periods[0], periods[plan.periods - 1]) ax.set_xlabel(\"Period\", size=14) ax.set_ylabel(\"Time in hours\", size=14)  plt.savefig(Path(\"figures\", \"worked_hours.png\"))"},{"location":"examples/sweden/#planning-the-swedish-economy","title":"Planning the swedish economy\u00b6","text":""},{"location":"examples/sweden/#the-plan","title":"The plan\u00b6","text":""},{"location":"examples/sweden/#visualizing-the-results","title":"Visualizing the results\u00b6","text":""},{"location":"examples/sweden/#production-unit-activity","title":"Production unit activity\u00b6","text":""},{"location":"examples/sweden/#production","title":"Production\u00b6","text":""},{"location":"examples/sweden/#excess-production","title":"Excess production\u00b6","text":""},{"location":"examples/sweden/#imported-final-goods","title":"Imported final goods\u00b6","text":""},{"location":"examples/sweden/#export-deficit","title":"Export deficit\u00b6","text":""},{"location":"examples/sweden/#total-worked-hours","title":"Total worked hours\u00b6","text":""},{"location":"reference/","title":"planning","text":""},{"location":"reference/#planning","title":"<code>planning</code>","text":""},{"location":"reference/_exceptions/","title":"_exceptions","text":""},{"location":"reference/_exceptions/#planning._exceptions","title":"<code>planning._exceptions</code>","text":"<p>Basic exception classes used to validate correct inputs in the economy.</p>"},{"location":"reference/_exceptions/#planning._exceptions.ShapeError","title":"<code>ShapeError(shape, desired_shape)</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>The shapes of different matrices of the economy don't match.</p> Source code in <code>planning/_exceptions.py</code> <pre><code>def __init__(self, shape: tuple[int, int], desired_shape: tuple[int, int]) -&gt; None:\n    message = f\"Shape is {shape}, instead of {desired_shape}.\\n\\n\"\n    logging.error(message)\n    super().__init__(message)\n</code></pre>"},{"location":"reference/_exceptions/#planning._exceptions.ShapesNotEqualError","title":"<code>ShapesNotEqualError()</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>The shapes of the matrices difer.</p> Source code in <code>planning/_exceptions.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"The shapes of the matrices in the same list differ.\\n\\n\")\n</code></pre>"},{"location":"reference/_version/","title":"_version","text":""},{"location":"reference/_version/#planning._version","title":"<code>planning._version</code>","text":""},{"location":"reference/ecology/","title":"ecology","text":""},{"location":"reference/ecology/#planning.ecology","title":"<code>planning.ecology</code>","text":"<p>Dataclasses to save the ecology and the planned ecology.</p>"},{"location":"reference/ecology/#planning.ecology--todo","title":"TODO:","text":"<pre><code>Add PlannedEcology class or merge it with planned economy.\n</code></pre>"},{"location":"reference/ecology/#planning.ecology.Ecology","title":"<code>Ecology</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass with validations that stores the whole economy's information.</p>"},{"location":"reference/ecology/#planning.ecology.Ecology.num_pollutants","title":"<code>num_pollutants</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/ecology/#planning.ecology.PlannedEcology","title":"<code>PlannedEcology(pollutants=list())</code>  <code>dataclass</code>","text":"<p>Dataclass that stores the whole planned economy.</p> <p>Parameters:</p> Name Type Description Default <code>activity</code> <code>list[NDArray]</code> <p>list with the planned activity for all sectors in each period.</p> required <code>production</code> <code>list[NDArray]</code> <p>list with the planned production for all product in each period.</p> required <code>surplus</code> <code>list[NDArray]</code> <p>The surplus production at the end of each period.</p> required <code>total_import</code> <code>list[NDArray]</code> <p>list of total imports in each period.</p> required <code>export_deficit</code> <code>list[float]</code> <p>list export deficit at the end of each period.</p> required <code>worked_hours</code> <code>list[float]</code> <p>list of total worked hours in each period.</p> required"},{"location":"reference/ecology/#planning.ecology.TargetEcology","title":"<code>TargetEcology</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass with validations that stores the whole economy's information.</p>"},{"location":"reference/ecology/#planning.ecology.TargetEcology.num_pollutants","title":"<code>num_pollutants</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/ecology/#planning.ecology.TargetEcology.periods","title":"<code>periods</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/ecology/#planning.ecology.TargetEcology.equal_sizes","title":"<code>equal_sizes(matrices, info)</code>","text":"<p>Assert that all the inputed matrices have the same size.</p> Source code in <code>planning/ecology.py</code> <pre><code>@field_validator(\"pollutants\")\ndef equal_sizes(cls, matrices: MatrixList, info: FieldValidationInfo) -&gt; MatrixList:\n    \"\"\"Assert that all the inputed matrices have the same size.\"\"\"\n    sizes = [matrix.size for matrix in matrices]\n    if not all([size == sizes[0] for size in sizes]):\n        raise ShapesNotEqualError\n    logging.info(f\"{info.field_name} has size {sizes[0]}\")\n    return matrices\n</code></pre>"},{"location":"reference/economy/","title":"economy","text":""},{"location":"reference/economy/#planning.economy","title":"<code>planning.economy</code>","text":"<p>Dataclasses to save the economy and the planned economy returned by the optimizer. The Economy class is implemented using Pydantic to perform certain checks in the data, which will normally come from a database, making it prone to mistakes when loading the data.</p>"},{"location":"reference/economy/#planning.economy.Economy","title":"<code>Economy</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass with validations that stores the whole economy's information.</p>"},{"location":"reference/economy/#planning.economy.Economy.periods","title":"<code>periods</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/economy/#planning.economy.Economy.products","title":"<code>products</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/economy/#planning.economy.Economy.sectors","title":"<code>sectors</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/economy/#planning.economy.Economy.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Run after initial validation. Validates that the shapes of the matrices are compatible with each other (same number of products and sectors).</p> Source code in <code>planning/economy.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Run after initial validation. Validates that the shapes of the\n    matrices are compatible with each other (same number of products\n    and sectors).\n    \"\"\"\n    self.validate_matrix_shape(\n        self.use_domestic[0], self.use_import[0], shape=(self.products, self.sectors)\n    )\n    self.validate_matrix_shape(self.depreciation[0], shape=(self.products, self.products))\n    self.validate_matrix_shape(\n        self.prices_import[0],\n        self.prices_export[0],\n        shape=(self.products,),\n    )\n    self.validate_matrix_shape(self.worked_hours[0], shape=(self.sectors,))\n\n    if self.product_names is not None and len(self.product_names) != self.products:\n        raise ValueError(f\"\\nList of PRODUCT names must be of length {self.products}.\\n\\n\")\n\n    if self.sector_names is not None and len(self.product_names) != self.products:\n        raise ValueError(f\"\\nList of SECTOR names must be of length {self.sectors}.\\n\\n\")\n</code></pre>"},{"location":"reference/economy/#planning.economy.Economy.equal_shapes","title":"<code>equal_shapes(matrices, info)</code>","text":"<p>Assert that all the inputed matrices have the same shape.</p> Source code in <code>planning/economy.py</code> <pre><code>@field_validator(*ECONOMY_FIELDS)\ndef equal_shapes(cls, matrices: MatrixList, info: FieldValidationInfo) -&gt; MatrixList:\n    \"\"\"Assert that all the inputed matrices have the same shape.\"\"\"\n    shapes = [matrix.shape for matrix in matrices]\n    if not all([shape == shapes[0] for shape in shapes]):\n        raise ShapesNotEqualError\n    logging.info(f\"{info.field_name} has shape {shapes[0]}\")\n    return matrices\n</code></pre>"},{"location":"reference/economy/#planning.economy.Economy.validate_matrix_shape","title":"<code>validate_matrix_shape(*matrices, shape)</code>  <code>staticmethod</code>","text":"<p>Assert that all the inputed matrices have the same shape.</p> Source code in <code>planning/economy.py</code> <pre><code>@staticmethod\ndef validate_matrix_shape(*matrices: MatrixList, shape: tuple[int, int]) -&gt; None:\n    \"\"\"Assert that all the inputed matrices have the same shape.\"\"\"\n    for matrix in matrices:\n        if matrix.shape != shape:\n            raise ShapeError(shape, matrix.shape)\n</code></pre>"},{"location":"reference/economy/#planning.economy.PlannedEconomy","title":"<code>PlannedEconomy(activity=list(), production=list(), surplus=list(), total_import=list(), export_deficit=list(), worked_hours=list())</code>  <code>dataclass</code>","text":"<p>Dataclass that stores the whole planned economy.</p> <p>Parameters:</p> Name Type Description Default <code>activity</code> <code>list[NDArray]</code> <p>list with the planned activity for all sectors in each period.</p> <code>list()</code> <code>production</code> <code>list[NDArray]</code> <p>list with the planned production for all product in each period.</p> <code>list()</code> <code>surplus</code> <code>list[NDArray]</code> <p>The surplus production at the end of each period.</p> <code>list()</code> <code>total_import</code> <code>list[NDArray]</code> <p>list of total imports in each period.</p> <code>list()</code> <code>export_deficit</code> <code>list[float]</code> <p>list export deficit at the end of each period.</p> <code>list()</code> <code>worked_hours</code> <code>list[float]</code> <p>list of total worked hours in each period.</p> <code>list()</code>"},{"location":"reference/economy/#planning.economy.TargetEconomy","title":"<code>TargetEconomy</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass with validations that stores the whole economy's information.</p>"},{"location":"reference/economy/#planning.economy.TargetEconomy.periods","title":"<code>periods</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/economy/#planning.economy.TargetEconomy.products","title":"<code>products</code>  <code>property</code>","text":"<p>Number of products in the economy.</p>"},{"location":"reference/economy/#planning.economy.TargetEconomy.equal_shapes","title":"<code>equal_shapes(matrices, info)</code>","text":"<p>Assert that all the inputed matrices have the same size.</p> Source code in <code>planning/economy.py</code> <pre><code>@field_validator(\"domestic\", \"exports\", \"imports\")\ndef equal_shapes(cls, matrices: MatrixList, info: FieldValidationInfo) -&gt; MatrixList:\n    \"\"\"Assert that all the inputed matrices have the same size.\"\"\"\n    sizes = [matrix.size for matrix in matrices]\n    if not all([size == sizes[0] for size in sizes]):\n        raise ShapesNotEqualError\n    logging.info(f\"{info.field_name} has shape {sizes[0]}\")\n    return matrices\n</code></pre>"},{"location":"reference/optimize/","title":"optimize","text":""},{"location":"reference/optimize/#planning.optimize","title":"<code>planning.optimize</code>","text":"<p>Optimize an Economy dataclass using linear programming.</p> TODO <p>Input targets as an object in optimizer?     - Target domestic     - Target export Add more ecological constraints</p>"},{"location":"reference/optimize/#planning.optimize.ErrorPeriods","title":"<code>ErrorPeriods()</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error in the number of revise periods given.</p> Source code in <code>planning/optimize.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.message = (\n        \"The number of periods provided in the economy must be greater\"\n        \"or equal to the number of periods we need to optimize our plan.\"\n    )\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.ErrorRevisePeriods","title":"<code>ErrorRevisePeriods()</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error in the number of periods given.</p> Source code in <code>planning/optimize.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.message = (\n        \"Number of revise periods must be less or equal the number of horizon periods.\"\n    )\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.InfeasibleProblem","title":"<code>InfeasibleProblem(iter_)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for infeasible LP problems in the input salary.</p> <p>Parameters:</p> Name Type Description Default <code>iter_</code> <code>int</code> <p>Current iteration of the linear programming algorithm.</p> required Source code in <code>planning/optimize.py</code> <pre><code>def __init__(self, iter_: int) -&gt; None:\n    message = (\n        f\"LP problem in iteration period {iter_} couldn't\"\n        \" be solved. You may try increasing the horizon periods\"\n        \" or the initial surplus production.\"\n    )\n    super().__init__(message)\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan","title":"<code>OptimizePlan(economy, ecology=None)</code>","text":"<p>Given the data for an economy, create the desired constraints and calculate the desired production for the upcoming years using linear programming and receding horizon control.</p> <p>To plan an economy, we need to solve the following linear programming problem</p> <p> </p> <p>subject to different constraints:</p> <ol> <li> <p>The activity of the production units must be positive at each period,      </p> </li> <li> <p>More is produced than it is consumed,      </p> </li> <li> <p>Trade balance is positive after a certain number of periods,      </p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>The number of periods to actually plan (discarding the horizon).</p> required <code>horizon_periods</code> <code>int</code> <p>The number of periods to plan in each iteration.</p> required <code>revise_periods</code> <code>int</code> <p>The number of periods after which to revise a plan.</p> required <code>economy</code> <code>EconomicPlan</code> <p>The economy, which contains supply-use tables, import prices...</p> required <p>Attributes:</p> Name Type Description <code>periods</code> <code>int</code> <p>The number of periods to actually plan (discarding the horizon). For example, we may want to plan the production for the next 4 years.</p> <code>horizon_periods</code> <code>int</code> <p>The number of periods to plan in each iteration. For example, we may want to use a horizon of 6 years.</p> <code>revise_periods</code> <code>int</code> <p>The number of periods after which to revise a plan. For example, if we planned a horizon of 6 years and we choose to revise the plan after 2 years, we discard the resting 4 years and plan again.</p> <code>economy</code> <code>EconomicPlan</code> <p>The economy, which contains supply-use tables, import prices...</p> <code>worked_hours</code> <code>list[NDArray]</code> <p>Total worked hours in each period.</p> <code>planned_activity</code> <code>list[NDArray]</code> <p>The planned activity for the production units in each period.</p> <code>planned_production</code> <code>list[NDArray]</code> <p>The planned production for each product in each period.</p> <code>planned_surplus</code> <code>list[NDArray]</code> <p>The surplus production at the end of each period.</p> <code>export_deficit</code> <code>list[NDArray]</code> <p>The export deficit at the end of each period.</p> <code>activity</code> <code>list[Variable]</code> <p>The activity variables of our LP problem, which correspond to the level of activation of each production unit.</p> <code>total_import</code> <code>list[Variable]</code> <p>The final imported products (variables) of our LP problem, which correspond to the level of activation of each production unit.</p> Source code in <code>planning/optimize.py</code> <pre><code>def __init__(\n    self,\n    economy: Economy,\n    ecology: Ecology | None = None,\n) -&gt; None:\n    self.economy = economy\n    self.ecology = ecology\n    self._validate_plan(economy)\n\n    self.planned_economy = PlannedEconomy()\n    self.planned_ecology = PlannedEcology()\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.__call__","title":"<code>__call__(periods, horizon_periods, revise_periods, target_economy, target_ecology=None, init_surplus=None, init_export_deficit=0)</code>","text":"<p>Optimize the plan over the specified periods and horizon.</p> <p>Parameters:</p> Name Type Description Default <code>init_surplus</code> <code>NDArray</code> <p>The surplus production at the initial time period. Defaults to None.</p> <code>None</code> <code>init_export_deficit</code> <code>float</code> <p>The export deficit at the initial time period. Defaults to None.</p> <code>0</code> Source code in <code>planning/optimize.py</code> <pre><code>def __call__(\n    self,\n    periods: int,\n    horizon_periods: int,\n    revise_periods: int,\n    target_economy: TargetEconomy,\n    target_ecology: TargetEcology | None = None,\n    init_surplus: NDArray | None = None,\n    init_export_deficit: float = 0,\n) -&gt; PlannedEconomy:\n    \"\"\"Optimize the plan over the specified periods and horizon.\n\n    Args:\n        init_surplus (NDArray, optional): The surplus production at the initial\n            time period. Defaults to None.\n        init_export_deficit (float, optional): The export deficit at the initial\n            time period. Defaults to None.\n    \"\"\"\n    self._validate_plan(self.economy)\n    self.periods: int = periods\n    self.horizon_periods: int = horizon_periods\n    self.revise_periods: int = revise_periods\n    self._initialize_plan_variables()\n    init_surplus = np.zeros(self.economy.products) if init_surplus is None else init_surplus\n\n    self.optimize_period(0, target_economy, target_ecology, init_surplus, init_export_deficit)\n    for period in range(self.revise_periods, self.periods, self.revise_periods):\n        self.optimize_period(\n            period,\n            target_economy,\n            target_ecology,\n            self.planned_economy.surplus[-1],\n            self.planned_economy.export_deficit[-1],\n        )\n    return self.planned_economy, self.planned_ecology\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.cost_harmony","title":"<code>cost_harmony(period, target_economy, surplus)</code>","text":"<p>Create the cost function to optimize and save the total worked hours in each period.  Args:     period (int): current period of the optimization. Returns:     Variable: Cost function to optimize.</p> Source code in <code>planning/optimize.py</code> <pre><code>def cost_harmony(\n    self, period: int, target_economy: TargetEconomy, surplus: NDArray\n) -&gt; Variable:\n    r\"\"\"Create the cost function to optimize and save the total worked hours in each period.\n    $$    \\text{minimize}\\: \\sum_{t=0}^T c_t \\cdot x_t  $$\n    Args:\n        period (int): current period of the optimization.\n    Returns:\n        Variable: Cost function to optimize.\n    \"\"\"\n    cost = 0\n    for t in range(period, period + self.horizon_periods):\n        supply_use = (\n            self.economy.supply[t] - self.economy.use_domestic[t] - self.economy.use_import[t]\n        )\n        production = supply_use @ self.activity[t]\n        final_planned = (\n            self.economy.depreciation[t] @ surplus + production + self.total_import[t]\n        )\n        final_target = (\n            target_economy.domestic[t] + target_economy.exports[t] + target_economy.imports[t]\n        )\n        surplus = final_planned - final_target\n\n        # cost += harmony(sum(surplus / final_target))\n        cost += sum(harmony(surplus) @ harmony(surplus))\n        # Record the planned production and the surplus production in the revised periods\n        if t &lt;= period + self.revise_periods - 1 and t &lt;= self.periods - 1:\n            self.surplus.append(surplus)\n            self.production.append(production)\n            self.worked_hours.append(self.economy.worked_hours[t] @ self.activity[t])\n\n    return cost\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.cost_hours","title":"<code>cost_hours(period)</code>","text":"<p>Create the cost function to optimize and save the total worked hours in each period.  Args:     period (int): current period of the optimization. Returns:     Variable: Cost function to optimize.</p> Source code in <code>planning/optimize.py</code> <pre><code>def cost_hours(self, period: int) -&gt; Variable:\n    r\"\"\"Create the cost function to optimize and save the total worked hours in each period.\n    $$    \\text{minimize}\\: \\sum_{t=0}^T c_t \\cdot x_t  $$\n    Args:\n        period (int): current period of the optimization.\n    Returns:\n        Variable: Cost function to optimize.\n    \"\"\"\n    cost = 0\n    for t in range(period, period + self.horizon_periods):\n        worked_hours = self.economy.worked_hours[t] @ self.activity[t]\n        import_prices = self.economy.prices_import[t] @ self.total_import[t]\n        # TODO: revise cost function. The more we penalize imports, the more hours we work\n        cost += worked_hours + import_prices\n\n        if t &lt;= period + self.revise_periods - 1:  # Record the worked hours in each period\n            self.worked_hours.append(worked_hours)\n    return cost\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.export_constraints","title":"<code>export_constraints(period, target_economy, export_deficit)</code>","text":"<p>We must export more than we import at the end of the horizon.</p> <p> </p> Note <p>If we don't force a positive deficit at the end of the revise period, we will have an ever increasing export deficit.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>current period of the optimization.</p> required <code>export_deficit</code> <code>float</code> <p>The export deficit at the end of each period.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[Constraint]</code> <p>Export constraints.</p> Source code in <code>planning/optimize.py</code> <pre><code>def export_constraints(\n    self, period: int, target_economy: TargetEconomy, export_deficit: float\n) -&gt; list[Constraint]:\n    r\"\"\"We must export more than we import at the end of the horizon.\n\n    $$ \\: \\sum_{t=1}^T \\: f^\\text{exp}_t \\cdot p^\\text{exp} \\: \\geq\n    \\: \\sum_{t=1}^T\\: (U^\\text{imp}_t \\cdot x_t + f^\\text{imp}_t) \\cdot p^\\text{imp}\\:. $$\n\n    Note:\n        If we don't force a positive deficit at the end of the revise period, we will have\n        an ever increasing export deficit.\n\n    Args:\n        period (int): current period of the optimization.\n        export_deficit (float): The export deficit at the end of each period.\n\n    Returns:\n        list: Export constraints.\n    \"\"\"\n    constraints = []\n    for t in range(period, period + self.horizon_periods):\n        total_price_export = self.economy.prices_export[t] @ target_economy.exports[t]\n        total_price_import = self.economy.prices_import[t] @ self.total_import[t]\n        # economy.use_import[t] @ self.activity[t] + self.target_import[t]\n        export_deficit = export_deficit + total_price_export - total_price_import\n        # Save the trade deficit in the revised periods\n        if t &lt;= period + self.revise_periods - 1 and t &lt;= self.periods - 1:\n            self.export_deficit.append(export_deficit)\n\n    # constraints.append(export_deficit &lt;= 1e6)  # Limit export deficit\n    constraints.append(export_deficit &gt;= 0)\n    return constraints\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.labor_realloc_constraint","title":"<code>labor_realloc_constraint(period)</code>","text":"<p>This constraint limits the reallocation of labor from one period to the next. For example, one cannot turn all farmers into train manufacturers in one year.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>current period of the optimization.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[Constraint]</code> <p>Labor reallocation constraints.</p> Source code in <code>planning/optimize.py</code> <pre><code>def labor_realloc_constraint(self, period: int) -&gt; list[Constraint]:\n    r\"\"\"This constraint limits the reallocation of labor from one period to the\n    next. For example, one cannot turn all farmers into train manufacturers in one year.\n\n    Args:\n        period (int): current period of the optimization.\n\n    Returns:\n        list: Labor reallocation constraints.\n    \"\"\"\n    realloc_coef = 0.1\n    realloc_low_limit = np.array([1 - realloc_coef] * self.economy.sectors)\n    realloc_upper_limit = np.array([1 + realloc_coef] * self.economy.sectors)\n    constraints = []\n    for t in range(period, period + self.horizon_periods):\n        if t == 0:  # No restrictions in the first period\n            continue\n        constraints.append(\n            self.activity[t] &gt;= multiply(realloc_low_limit, self.activity[t - 1])\n        )\n        constraints.append(\n            self.activity[t] &lt;= multiply(realloc_upper_limit, self.activity[t - 1])\n        )\n    return constraints\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.optimize_period","title":"<code>optimize_period(period, target_economy, target_ecology, surplus, export_deficit)</code>","text":"<p>Optimize one period of the plan.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>current period of the optimization.</p> required <code>surplus</code> <code>NDArray</code> <p>The surplus production at the end of each period.</p> required <code>export_deficit</code> <code>float</code> <p>The export deficit at the end of each period.</p> required <p>Raises:</p> Type Description <code>InfeasibleProblem</code> <p>Exception raised for infeasible LP problems in the input salary.</p> Source code in <code>planning/optimize.py</code> <pre><code>def optimize_period(\n    self,\n    period: int,\n    target_economy: TargetEconomy,\n    target_ecology: TargetEcology,\n    surplus: NDArray,\n    export_deficit: float,\n) -&gt; None:\n    \"\"\"Optimize one period of the plan.\n\n    Args:\n        period (int): current period of the optimization.\n        surplus (NDArray): The surplus production at the end of each period.\n        export_deficit (float): The export deficit at the end of each period.\n\n    Raises:\n        InfeasibleProblem: Exception raised for infeasible LP problems in the input salary.\n    \"\"\"\n    constraints = self.export_constraints(period, target_economy, export_deficit)\n    # constraints += self.production_constraints(period, target_economy, surplus)\n    constraints += self.labor_realloc_constraint(period)\n    if self.ecology is not None:\n        constraints += self.pollutants_constraint(period, target_ecology)\n    # objective = Minimize(self.cost(period))\n    objective = Minimize(self.cost_harmony(period, target_economy, surplus))\n    problem = Problem(objective, constraints)\n    problem.solve(verbose=False)\n\n    if problem.status in [\"infeasible\", \"unbounded\"]:\n        logging.error(f\"Problem value is {problem.value}.\")\n        raise InfeasibleProblem(period)\n\n    self._save_plan_period(period)\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.pollutants_constraint","title":"<code>pollutants_constraint(period, target_ecology)</code>","text":"<p>Maximum pollution allowed.</p> Source code in <code>planning/optimize.py</code> <pre><code>def pollutants_constraint(self, period: int, target_ecology: TargetEcology) -&gt; list[Constraint]:\n    r\"\"\"Maximum pollution allowed.\"\"\"\n    constraints = []\n    for t in range(period, period + self.horizon_periods):\n        produced_pollutants = self.ecology.pollutant_sector[t] @ self.activity[t]\n        constraints.append(produced_pollutants &lt;= target_ecology.pollutants[t])\n        # Record the planned production and the surplus production in the revised periods\n        if t &lt;= period + self.revise_periods - 1 and t &lt;= self.periods - 1:\n            self.produced_pollutants.append(produced_pollutants)\n    return constraints\n</code></pre>"},{"location":"reference/optimize/#planning.optimize.OptimizePlan.production_constraints","title":"<code>production_constraints(period, target_economy, surplus)</code>","text":"<p>We must produce more than the target output,  </p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>current period of the optimization.</p> required <code>surplus</code> <code>NDArray</code> <p>the surplus production at the end of each period.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[Constraint]</code> <p>Production meets target constraints.</p> Source code in <code>planning/optimize.py</code> <pre><code>def production_constraints(\n    self, period: int, target_economy: TargetEconomy, surplus: NDArray\n) -&gt; list[Constraint]:\n    r\"\"\"We must produce more than the target output,\n    $$e_{t-1} + S_t \\cdot x_t - U^\\text{dom}_t \\cdot x_t +\n    f^\\text{imp}_t \\geq f^\\text{exp}_t + f^\\text{dom}_t \\:.$$\n\n    Args:\n        period (int): current period of the optimization.\n        surplus (NDArray): the surplus production at the end of each period.\n\n    Returns:\n        list: Production meets target constraints.\n    \"\"\"\n    constraints = []\n    for t in range(period, period + self.horizon_periods):\n        supply_use = (\n            self.economy.supply[t] - self.economy.use_domestic[t] - self.economy.use_import[t]\n        )\n        production = supply_use @ self.activity[t]\n        surplus = (\n            self.economy.depreciation[t] @ surplus\n            + production\n            + self.total_import[t]\n            - target_economy.domestic[t]\n            - target_economy.exports[t]\n            - target_economy.imports[t]\n        )\n        constraints.append(surplus &gt;= 0)\n        # Record the planned production and the surplus production in the revised periods\n        if t &lt;= period + self.revise_periods - 1 and t &lt;= self.periods - 1:\n            self.surplus.append(surplus)\n            self.production.append(production)\n    return constraints\n</code></pre>"},{"location":"scripts/copy_examples/","title":"Copy examples","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Script to copy the examples folder into the docs.\n\"\"\"\n</pre> \"\"\"Script to copy the examples folder into the docs. \"\"\" In\u00a0[\u00a0]: Copied! <pre>import shutil\nfrom pathlib import Path\n</pre> import shutil from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>spain_path = Path(\"examples\", \"Spain\", \"spain.ipynb\")\nsweden_path = Path(\"examples\", \"Sweden\", \"sweden.ipynb\")\n</pre> spain_path = Path(\"examples\", \"Spain\", \"spain.ipynb\") sweden_path = Path(\"examples\", \"Sweden\", \"sweden.ipynb\") In\u00a0[\u00a0]: Copied! <pre>docs_path = Path(\"docs\", \"examples\")\n</pre> docs_path = Path(\"docs\", \"examples\") In\u00a0[\u00a0]: Copied! <pre>shutil.copy(spain_path, docs_path)\nshutil.copy(sweden_path, docs_path)\n</pre> shutil.copy(spain_path, docs_path) shutil.copy(sweden_path, docs_path)"},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Script to generate the documentation pages and navigation for our library.\n\nImportant: remember to change PATH_LIBRARY to whatever name your package\nfolder has!!\n\"\"\"\n</pre> \"\"\"Script to generate the documentation pages and navigation for our library.  Important: remember to change PATH_LIBRARY to whatever name your package folder has!! \"\"\" In\u00a0[\u00a0]: Copied! <pre>import sys\nimport os\nfrom pathlib import Path\n</pre> import sys import os from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nPATH_LIBRARY = \"planning\"  # change this with your library's name\n</pre> nav = mkdocs_gen_files.Nav() PATH_LIBRARY = \"planning\"  # change this with your library's name In\u00a0[\u00a0]: Copied! <pre>if os.path.isdir(PATH_LIBRARY) is False:\n    sys.exit(\n        \"Package folder was not found. Please change the PATH_LIBRARY\"\n        \" variable in the docs/scripts/gen_ref_nav.py script.\"\n    )\n</pre> if os.path.isdir(PATH_LIBRARY) is False:     sys.exit(         \"Package folder was not found. Please change the PATH_LIBRARY\"         \" variable in the docs/scripts/gen_ref_nav.py script.\"     ) In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(PATH_LIBRARY).rglob(\"*.py\")):\n    module_path = path.relative_to(\"\").with_suffix(\"\")\n    doc_path = path.relative_to(PATH_LIBRARY).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\\n\")\n        fd.write(\"\\thandler: python\\n\")\n        fd.write(\"\\toptions:\\n\")\n        fd.write(\"\\t\\tshow_root_heading: true\\n\")\n        fd.write(\"\\t\\tshow_source: true\\n\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)\n</pre> for path in sorted(Path(PATH_LIBRARY).rglob(\"*.py\")):     module_path = path.relative_to(\"\").with_suffix(\"\")     doc_path = path.relative_to(PATH_LIBRARY).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\\n\")         fd.write(\"\\thandler: python\\n\")         fd.write(\"\\toptions:\\n\")         fd.write(\"\\t\\tshow_root_heading: true\\n\")         fd.write(\"\\t\\tshow_source: true\\n\")      mkdocs_gen_files.set_edit_path(full_doc_path, path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}]}